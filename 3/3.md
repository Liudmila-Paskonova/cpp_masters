# HW 3

## 3.1

Для сборки

```
mkdir -p build
cmake -S . -B build
cmake --build build --parallel
ctest --test-dir build --output-on-failure

```
## 3.2 

Output компилятора(-ов): 
```bash
<source>:14:10: error: no matching function for call to 'add_variadic'
   14 |   return add_variadic(1, 2); // FAIL
      |          ^~~~~~~~~~~~
<source>:9:39: note: candidate template ignored: constraints not satisfied [with Ts = <int, int>]
    9 | template <VariadicAddable... Ts> auto add_variadic(Ts... vs) {
      |                                       ^
<source>:9:11: note: because 'int' does not satisfy 'VariadicAddable'
    9 | template <VariadicAddable... Ts> auto add_variadic(Ts... vs) {
      |           ^
<source>:6:14: note: because 'sizeof...(Ts) > 1' (1 > 1) evaluated to false
    6 |     requires sizeof...(Ts) > 1;
      |              ^
<source>:9:11: note: and 'int' does not satisfy 'VariadicAddable'
    9 | template <VariadicAddable... Ts> auto add_variadic(Ts... vs) {
      |           ^
<source>:6:14: note: because 'sizeof...(Ts) > 1' (1 > 1) evaluated to false
    6 |     requires sizeof...(Ts) > 1;
```

Ситуация: ```'sizeof...(Ts) > 1' (1 > 1) evaluated to false```, компилятор пытается проверить не все типы parameter pack, а каждый тип по отдельности. Происходит это потому, что согласно стандарту requires expression может проверять на синтаксическое соответствие только **один тип** ([expr.prim.req.type]):
```
    type-requirement:
        typename nested-name-specifier type-name ;
```

Чтобы оценить весь parameter pack, нужно добавить внешний requires, чтобы раскрыть его at compile time:

```cpp
template <typename... Ts>
  requires VariadicAddable<Ts...> 
auto add_variadic(Ts... vs) {
  return (... + vs);
}
```

Полный компилируемый пример здесь: https://godbolt.org/z/578Yns6f9 .
