# HW 4

# 4.1

Clang скомпилирует программу, а GCC посчитает, что перегрузка ambiguous: https://godbolt.org/z/88snn3MGE

``` bash
4_1.cpp: In function ‘int main()’:
4_1.cpp:26:15: error: call of overloaded ‘f(<brace-enclosed initializer list>)’ is ambiguous
   26 |     auto b = f({{}, {}});
      |              ~^~~~~~~~~~
4_1.cpp:26:15: note: there are 2 candidates
4_1.cpp:13:1: note: candidate 1: ‘int f(Pair<E, E>)’
   13 | f(Pair<E, E>)
      | ^
4_1.cpp:18:1: note: candidate 2: ‘int f(Pair<S, S>)’
   18 | f(Pair<S, S>)
      | ^
```

Я думаю, что Clang прав, выбирая ```f(Pair<S, S>)```, так как у E - конструктор ```explicit```, и ```f(Pair<E, E>)``` выпадает из изначального множества перегрузки на этапе ICS (нет возможностей для преобразований, в т ч пользовательского).

А вот на ```static_assert``` ругаются оба компилятора: https://godbolt.org/z/szdc13zG3 . GCC с той же ошибкой -- двумя кандидатами на перегрузку -- а Clang на то, что соответствующие конструкторы не ```constexpr```:

```bash
4_1.cpp:25:19: error: static assertion expression is not an integral constant expression
   25 |     static_assert(f({{}, {}}) == 2, ""); // Error or Assert or OK?
      |                   ^~~~~~~~~~~~~~~~
4_1.cpp:25:21: note: non-constexpr constructor 'Pair<S, S>' cannot be used in a constant expression
   25 |     static_assert(f({{}, {}}) == 2, ""); // Error or Assert or OK?
      |                     ^
4_1.cpp:3:45: note: declared here
    3 |     template <class U1 = T1, class U2 = T2> Pair(U1 &&, U2 &&) {}
```

Однако же если поставить нужные ```constexpr```, clang все скомпилирует (GCC стабильно нет): https://godbolt.org/z/eMfbKqzK6 .

## 4.2

И Clang, и GCC считают, что будет выведено "Bar": https://godbolt.org/z/n9EGrMfec .

Кажется, оба правы согласно [over.ics.rank] (в драфте 23 стандарта конкретно п. 3.2.6):

**Standart conversion sequence S1 is a better conversion sequence than a standart conversion sequence S2** if...

S1 and S2 include reference bindings (9.4.4), and the types to which the references refer are the same type except for top-level cv-qualifiers, and the **type to which the reference initialized by S2 refers is more cv-qualified than the type to which the reference initialized by S1 refers**.